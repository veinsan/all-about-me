<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="uts-1-all-about-me" class="level1">
<h1>UTS-1 All About Me</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/ya.jpeg" class="img-fluid figure-img" style="width:950.0%"></p>
<figcaption>About Me</figcaption>
</figure>
</div>
<p>Halo halo! Perkenalkan, saya Riantama Putra, mahasiswa Program Studi Sistem dan Teknologi Informasi, Institut Teknologi Bandung, Angkatan 2024. Melalui tugas <em>All About Me</em> ini, saya ingin mengenali diri saya lebih dalam, bukan hanya sebagai mahasiswa, tetapi juga sebagai pribadi yang sedang belajar memahami makna komunikasi, baik dengan diri sendiri maupun dengan orang lain.</p>
<section id="tentang-saya" class="level2">
<h2 class="anchored" data-anchor-id="tentang-saya">Tentang Saya</h2>
<p>Saya melihat diri saya sebagai seseorang yang rasional tetapi tetap hangat. Saya terbiasa berpikir dengan logika, namun tetap menghargai sisi emosional dalam setiap interaksi. Dalam percakapan, saya lebih suka mendengarkan terlebih dahulu dan mencoba memahami konteks sebelum menanggapi. Namun, saya juga menyadari bahwa terkadang saya terlalu berhati-hati, seolah takut dinilai salah. Dari sana saya belajar bahwa komunikasi bukan soal menjadi sempurna, melainkan soal berani hadir apa adanya dan mau memahami sebelum dipahami.</p>
<p>Saya percaya setiap orang memiliki cara unik untuk mengekspresikan diri. Bagi saya, berbicara adalah proses untuk jujur terhadap diri sendiri, dan mendengarkan adalah cara untuk memahami dunia dengan lebih luas.</p>
</section>
<section id="nilai-dan-prinsip-yang-membentuk-saya" class="level2">
<h2 class="anchored" data-anchor-id="nilai-dan-prinsip-yang-membentuk-saya">Nilai dan Prinsip yang Membentuk Saya</h2>
<p>Dalam hidup, saya berpegang pada tiga hal: <strong>kejujuran, empati, dan tanggung jawab</strong>. Kejujuran membuat saya bisa hidup tanpa berpura-pura. Empati membantu saya memahami sudut pandang orang lain tanpa langsung menghakimi. Dan tanggung jawab mengingatkan saya bahwa setiap kata yang diucapkan membawa konsekuensi.</p>
<p>Dari perkuliahan ini, saya memahami bahwa nilai-nilai ini menjadi dasar dalam <em>self-concept</em> dan <em>self-awareness</em>. Mengetahui siapa diri saya dan apa yang saya hargai membantu saya berkomunikasi dengan lebih sadar, terbuka, dan penuh tujuan. Saya juga belajar bahwa mendengarkan dengan niat tulus dapat menciptakan hubungan yang lebih bermakna dibanding sekadar berbicara panjang lebar.</p>
</section>
<section id="cara-saya-melihat-dunia-dan-orang-lain" class="level2">
<h2 class="anchored" data-anchor-id="cara-saya-melihat-dunia-dan-orang-lain">Cara Saya Melihat Dunia dan Orang Lain</h2>
<p>Saya melihat dunia sebagai ruang untuk belajar. Tidak semua pelajaran datang dari ruang kuliah, sebagian justru hadir lewat kesalahpahaman, kegagalan, atau percakapan sederhana. Setiap kali saya berinteraksi, saya berusaha untuk tidak hanya memahami kata-kata, tetapi juga perasaan dan makna yang tersirat di baliknya.</p>
<p>Melalui teori komunikasi interpersonal, saya menyadari bahwa persepsi sering kali menjadi sumber kesalahpahaman. Konflik tidak selalu muncul karena niat buruk, tetapi karena perbedaan cara pandang. Karena itu, saya mencoba menerapkan prinsip <strong>“clarify before judge”</strong> yang memiliki arti mencari makna sebelum menyimpulkan. Pemahaman tentang persepsi ini membantu saya mengurangi prasangka dan memperkuat keterampilan empatik dalam berinteraksi.</p>
</section>
<section id="kepribadian-dan-kehidupan-sehari-hari" class="level2">
<h2 class="anchored" data-anchor-id="kepribadian-dan-kehidupan-sehari-hari">Kepribadian dan Kehidupan Sehari-hari</h2>
<p>Secara kepribadian, saya bisa dibilang cukup seimbang antara introvert dan ekstrovert. Saya nyaman bekerja sendiri, tetapi juga menikmati waktu bersama teman-teman yang punya energi positif. Di luar akademik, saya menikmati hal-hal sederhana seperti mendengarkan musik, bermain game, atau sekadar merenung sendiri. Momen-momen itu membantu saya memahami diri saya dan mengatur emosi dengan lebih baik.</p>
<p>Saya belajar dari topik komunikasi nonverbal bahwa keheningan juga bisa berbicara. Cara kita menatap, tersenyum, atau menunduk dapat menyampaikan pesan tanpa kata-kata. Karena itu, saya mulai lebih sadar terhadap bahasa tubuh saya dan mencoba menyesuaikannya agar selaras dengan pesan yang ingin saya sampaikan.</p>
</section>
<section id="refleksi-atas-diri-dan-komunikasi" class="level2">
<h2 class="anchored" data-anchor-id="refleksi-atas-diri-dan-komunikasi">Refleksi atas Diri dan Komunikasi</h2>
<p>Selama mengikuti perkuliahan ini, saya belajar bahwa komunikasi sejati berawal dari kesadaran diri (<em>self-awareness</em>). Cara saya menilai diri sendiri ternyata memengaruhi cara saya mendengar, memahami, dan berbicara dengan orang lain. Saya belajar untuk tidak mencari penerimaan dari semua orang (<em>approval seeking</em>), tetapi untuk berbicara dengan niat tulus dan menghargai perbedaan perspektif.</p>
<p>Saya juga mulai menerapkan <em>affirmation</em>, yaitu berbicara baik kepada diri sendiri. Satu kalimat positif kadang cukup untuk menenangkan pikiran dan membantu saya menghadapi situasi sulit dengan kepala dingin. Dari situ saya belajar bahwa komunikasi intrapersonal adalah pondasi dari hubungan interpersonal yang sehat.</p>
<p>Dari materi <em>Listening</em> saya menyadari pentingnya menjadi pendengar aktif. Saya berusaha lebih fokus saat orang lain berbicara, memparafrasekan untuk memastikan pemahaman saya benar, dan menghindari kebiasaan <em>pseudolistening</em>. Dengan mendengar sepenuhnya, saya bukan hanya memahami pesan, tetapi juga menghargai manusia di baliknya.</p>
</section>
<section id="harapan-dan-tujuan-ke-depan" class="level2">
<h2 class="anchored" data-anchor-id="harapan-dan-tujuan-ke-depan">Harapan dan Tujuan ke Depan</h2>
<p>Saya ingin menjadi pribadi yang tidak hanya cerdas secara teknis, tetapi juga bijak dalam berinteraksi. Saya ingin kemampuan komunikasi saya tidak berhenti pada penyampaian pesan, melainkan mampu membangun kepercayaan dan kerja sama. Saya berharap dapat menciptakan lingkungan yang terbuka, suportif, dan saling memahami, baik dalam konteks akademik maupun profesional.</p>
<p>Bagi saya, komunikasi yang baik adalah cerminan kematangan diri. <em>All About Me</em> bukan sekadar tugas, tetapi proses belajar untuk tumbuh menjadi pribadi yang memahami diri sendiri, mampu mendengarkan, dan membawa nilai positif dalam setiap percakapan.</p>
<hr>
<blockquote class="blockquote">
<p>“Menjadi pendengar yang baik kadang lebih sulit daripada menjadi pembicara yang hebat. Tetapi di sanalah kita belajar, bahwa memahami orang lain selalu dimulai dari keberanian untuk mendengarkan.”</p>
</blockquote>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>